<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drive Mad Clone</title>
    <style>
        body { margin: 0; background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 100%); display: flex; flex-direction: column; align-items: center; font-family: Arial, sans-serif; }
        canvas { border: 3px solid #333; background: linear-gradient(#90EE90, #228B22); box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-size: 20px; text-shadow: 2px 2px 4px black; }
        #levelComplete { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,255,0,0.9); color: black; padding: 20px; border-radius: 10px; font-size: 32px; display: none; text-align: center; }
        button { margin-top: 10px; padding: 10px 20px; font-size: 18px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ui">
        <div>Level: <span id="level">1</span> | Speed: <span id="speed">0</span></div>
        <div>Arrow Keys / WASD: Drive & Balance</div>
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="levelComplete">
        <div>Level Complete! ðŸŽ‰</div>
        <button onclick="nextLevel()">Next Level</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const levelEl = document.getElementById('level');
        const speedEl = document.getElementById('speed');
        const completeEl = document.getElementById('levelComplete');

        // Physics
        let car = { x: 100, y: 400, vx: 0, vy: 0, angle: 0, angularVel: 0, size: 30, color: '#FF4444' };
        let keys = {};
        let currentLevel = 1;
        let cameraX = 0;
        let gameWon = false;

        // Input
        document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // Levels: platforms, ramps, obstacles (simple poly lines)
        const levels = [
            // Level 1: Flat
            [{ points: [[0,500],[800,500]], color: '#8B4513' }, { points: [[0,550],[800,550]], color: '#654321' }, { flag: [750,450] }],
            // Level 2: Ramp
            [{ points: [[0,500],[400,500],[450,400],[800,400]], color: '#8B4513' }, { points: [[0,550],[800,550]], color: '#654321' }, { flag: [750,350] }],
            // Level 3: Bump
            [{ points: [[0,500],[200,500],[250,450],[400,450],[450,500],[800,500]], color: '#8B4513' }, { points: [[0,550],[800,550]], color: '#654321' }, { flag: [750,450] }],
            // Add more levels...
            [{ points: [[0,500],[100,500],[150,400],[300,400],[350,500],[800,500]], color: '#8B4513' }, { points: [[0,550],[800,550]], color: '#654321' }, { flag: [750,450] }]
        ];

        let levelData = levels[0];

        function update() {
            if (gameWon) return;

            // Input
            let accel = 0;
            let tilt = 0;
            if (keys['arrowup'] || keys['w']) accel = 0.3;
            if (keys['arrowdown'] || keys['s']) accel = -0.2;
            if (keys['arrowleft'] || keys['a']) tilt = -0.05;
            if (keys['arrowright'] || keys['d']) tilt = 0.05;

            // Physics update
            car.angularVel += tilt;
            car.angularVel *= 0.9; // Damp
            car.angle += car.angularVel;

            let dx = Math.cos(car.angle) * accel;
            let dy = Math.sin(car.angle) * accel;
            car.vx += dx;
            car.vy += dy;

            car.vx *= 0.98; // Friction
            car.vy *= 0.98;
            car.x += car.vx;
            car.y += car.vy;

            speedEl.textContent = Math.sqrt(car.vx*car.vx + car.vy*car.vy).toFixed(1);

            // Camera follow
            cameraX = car.x - canvas.width / 2;

            // Collision with ground (simple line collision)
            collideWithLevel();

            // Check flag
            if (levelData.flag && Math.hypot(car.x - levelData.flag[0], car.y - levelData.flag[1]) < 40) {
                completeEl.style.display = 'block';
            }

            // Flip check (if too tilted)
            if (Math.abs(car.angle) > Math.PI / 2) {
                alert('Flipped! Restarting level...');
                resetLevel();
            }
        }

        function collideWithLevel() {
            for (let obj of levelData) {
                if (obj.points) {
                    // Simple point-to-line collision for car center (approx)
                    for (let i = 0; i < obj.points.length - 1; i++) {
                        let p1 = obj.points[i], p2 = obj.points[i+1];
                        let dist = pointToLineDist(car.x, car.y, p1[0], p1[1], p2[0], p2[1]);
                        if (dist < car.size / 2) {
                            // Reflect velocity
                            let normal = perpendicular(p2[0] - p1[0], p2[1] - p1[1]);
                            let dot = car.vx * normal[0] + car.vy * normal[1];
                            car.vx -= 2 * dot * normal[0];
                            car.vy -= 2 * dot * normal[1];
                            // Push out
                            let push = (car.size / 2 - dist) * 1.1;
                            car.x += normal[0] * push;
                            car.y += normal[1] * push;
                        }
                    }
                }
            }
        }

        function pointToLineDist(px, py, x1, y1, x2, y2) {
            let A = px - x1;
            let B = py - y1;
            let C = x2 - x1;
            let D = y2 - y1;
            let dot = A * C + B * D;
            let lenSq = C * C + D * D;
            let param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            let dx = px - xx;
            let dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function perpendicular(dx, dy) {
            let len = Math.sqrt(dx*dx + dy*dy);
            return [ -dy / len, dx / len ];
        }

        function resetLevel() {
            car.x = 100;
            car.y = 400;
            car.vx = 0;
            car.vy = 0;
            car.angle = 0;
            car.angularVel = 0;
            cameraX = 0;
        }

        function nextLevel() {
            currentLevel++;
            levelEl.textContent = currentLevel;
            if (currentLevel >= levels.length) {
                alert('You beat all levels! ðŸŽŠ');
                gameWon = true;
                return;
            }
            levelData = levels[currentLevel % levels.length]; // Cycle for demo
            resetLevel();
            completeEl.style.display = 'none';
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw level
            ctx.save();
            ctx.translate(-cameraX, 0);
            for (let obj of levelData) {
                if (obj.points) {
                    ctx.fillStyle = obj.color;
                    ctx.beginPath();
                    ctx.moveTo(obj.points[0][0], obj.points[0][1]);
                    for (let i = 1; i < obj.points.length; i++) {
                        ctx.lineTo(obj.points[i][0], obj.points[i][1]);
                    }
                    ctx.lineTo(obj.points[obj.points.length-1][0], obj.points[obj.points.length-1][1] + 50);
                    ctx.lineTo(obj.points[0][0], obj.points[0][1] + 50);
                    ctx.closePath();
                    ctx.fill();
                }
                if (obj.flag) {
                    ctx.fillStyle = 'lime';
                    ctx.fillRect(obj.flag[0]-10, obj.flag[1]-30, 20, 40);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(obj.flag[0]-5, obj.flag[1]-35, 10, 10);
                }
            }
            ctx.restore();

            // Draw car
            ctx.save();
            ctx.translate(car.x - cameraX, car.y);
            ctx.rotate(car.angle);
            ctx.fillStyle = car.color;
            ctx.fillRect(-car.size/2, -10, car.size, 20);
            ctx.fillStyle = '#000';
            ctx.fillRect(-car.size/2 + 5, -8, 8, 6);
            ctx.fillRect(car.size/2 - 13, -8, 8, 6);
            ctx.restore();
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        levelEl.textContent = currentLevel;
        resetLevel();
        loop();
    </script>
</body>
</html>
